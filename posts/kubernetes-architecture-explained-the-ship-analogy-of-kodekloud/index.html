<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes Architecture Explained the Ship Analogy of KodeKloud | Book of Daniel</title>
<meta name=keywords content="k8s"><meta name=description content="Welcome to our exploration of Kubernetes architecture! Kubernetes, often abbreviated as K8s, is a powerful tool designed to manage containerized applications in a scalable and automated fashion. This blog post aims to provide a high-level understanding of Kubernetes architecture using an analogy of ships, which simplifies the complex interplay between its components. Special thanks to KodeKloud for their insightful lecture, which inspired this overview.
The Kubernetes Cluster: Ships at Sea
At its core, a Kubernetes cluster comprises two types of nodes: worker nodes and master nodes. To understand their roles, let&rsquo;s imagine a fleet of ships:"><meta name=author content="Dan"><link rel=canonical href=https://bookofdaniel.in/posts/kubernetes-architecture-explained-the-ship-analogy-of-kodekloud/><meta name=google-site-verification content="G-VXV565Z72E"><link crossorigin=anonymous href=/assets/css/stylesheet.f4293b8f53210bcabd910256bfd1bad549ca35946bf52a51c2e8d0bbc7e42cc8.css integrity="sha256-9Ck7j1MhC8q9kQJWv9G61UnKNZRr9SpRwujQu8fkLMg=" rel="preload stylesheet" as=style><link rel=icon href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bookofdaniel.in/posts/kubernetes-architecture-explained-the-ship-analogy-of-kodekloud/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href=https://fonts.cdnfonts.com/css/code-new-roman rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-VXV565Z72E"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VXV565Z72E")}</script><meta property="og:title" content="Kubernetes Architecture Explained the Ship Analogy of KodeKloud"><meta property="og:description" content="Welcome to our exploration of Kubernetes architecture! Kubernetes, often abbreviated as K8s, is a powerful tool designed to manage containerized applications in a scalable and automated fashion. This blog post aims to provide a high-level understanding of Kubernetes architecture using an analogy of ships, which simplifies the complex interplay between its components. Special thanks to KodeKloud for their insightful lecture, which inspired this overview.
The Kubernetes Cluster: Ships at Sea
At its core, a Kubernetes cluster comprises two types of nodes: worker nodes and master nodes. To understand their roles, let&rsquo;s imagine a fleet of ships:"><meta property="og:type" content="article"><meta property="og:url" content="https://bookofdaniel.in/posts/kubernetes-architecture-explained-the-ship-analogy-of-kodekloud/"><meta property="og:image" content="https://bookofdaniel.in/images/k8s-ship-analogy-kodekloud.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-12T13:52:32+05:30"><meta property="article:modified_time" content="2024-09-12T13:52:32+05:30"><meta property="og:site_name" content="Book of Daniel"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bookofdaniel.in/images/k8s-ship-analogy-kodekloud.webp"><meta name=twitter:title content="Kubernetes Architecture Explained the Ship Analogy of KodeKloud"><meta name=twitter:description content="Welcome to our exploration of Kubernetes architecture! Kubernetes, often abbreviated as K8s, is a powerful tool designed to manage containerized applications in a scalable and automated fashion. This blog post aims to provide a high-level understanding of Kubernetes architecture using an analogy of ships, which simplifies the complex interplay between its components. Special thanks to KodeKloud for their insightful lecture, which inspired this overview.
The Kubernetes Cluster: Ships at Sea
At its core, a Kubernetes cluster comprises two types of nodes: worker nodes and master nodes. To understand their roles, let&rsquo;s imagine a fleet of ships:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bookofdaniel.in/posts/"},{"@type":"ListItem","position":2,"name":"Kubernetes Architecture Explained the Ship Analogy of KodeKloud","item":"https://bookofdaniel.in/posts/kubernetes-architecture-explained-the-ship-analogy-of-kodekloud/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes Architecture Explained the Ship Analogy of KodeKloud","name":"Kubernetes Architecture Explained the Ship Analogy of KodeKloud","description":"Welcome to our exploration of Kubernetes architecture! Kubernetes, often abbreviated as K8s, is a powerful tool designed to manage containerized applications in a scalable and automated fashion. This blog post aims to provide a high-level understanding of Kubernetes architecture using an analogy of ships, which simplifies the complex interplay between its components. Special thanks to KodeKloud for their insightful lecture, which inspired this overview.\nThe Kubernetes Cluster: Ships at Sea At its core, a Kubernetes cluster comprises two types of nodes: worker nodes and master nodes. To understand their roles, let\u0026rsquo;s imagine a fleet of ships:\n","keywords":["k8s"],"articleBody":"Welcome to our exploration of Kubernetes architecture! Kubernetes, often abbreviated as K8s, is a powerful tool designed to manage containerized applications in a scalable and automated fashion. This blog post aims to provide a high-level understanding of Kubernetes architecture using an analogy of ships, which simplifies the complex interplay between its components. Special thanks to KodeKloud for their insightful lecture, which inspired this overview.\nThe Kubernetes Cluster: Ships at Sea At its core, a Kubernetes cluster comprises two types of nodes: worker nodes and master nodes. To understand their roles, let’s imagine a fleet of ships:\nWorker Nodes (Cargo Ships): These ships carry the actual load—in Kubernetes, this translates to running your containerized applications. Master Nodes (Control Ships): These ships oversee and manage the cargo ships, ensuring everything runs smoothly. Master Nodes: The Control Ships Master nodes are the brain of the Kubernetes cluster, managing the state and operations of the entire system. They contain several key components, collectively known as the control plane:\netcd: A highly available key-value store that keeps all cluster data. Think of it as the central database that logs the details of every ship and container.\nKube Scheduler: Similar to cranes that load containers onto ships, the Kube Scheduler assigns containers to nodes based on resource requirements, node capacity, and various constraints like node affinity and tolerations.\nControllers: These are specialized offices on the control ships handling specific tasks:\nNode Controller: Manages the state of nodes, ensuring they are operational and adding new ones to the cluster as needed. Replication Controller: Ensures the desired number of container replicas are running at all times. Kube API Server: The central management component that orchestrates all operations within the cluster. It exposes the Kubernetes API, allowing users and controllers to interact with the cluster, monitor its state, and make necessary changes.\nWorker Nodes: The Cargo Ships Worker nodes are where your applications run, managed by two key components:\nKubelet: The captain of the ship, responsible for communicating with the Kube API Server, receiving instructions, and managing containers on the node. The Kubelet also sends status reports back to the master nodes.\nKube-proxy: Ensures smooth communication between containers across different nodes by maintaining network rules on each node. This is essential for services to interact seamlessly, like a web server on one node communicating with a database server on another.\nContainer Runtime All nodes, whether master or worker, require a container runtime engine to run containers. While Docker is a popular choice, Kubernetes also supports other runtimes like containerd and CRI-O. This runtime environment is crucial for deploying containerized applications and components.\nConclusion Kubernetes architecture, with its intricate components and interactions, ensures efficient and scalable management of containerized applications. By likening it to a fleet of ships with dedicated roles and responsibilities, we can better understand the complex but elegant orchestration that Kubernetes provides.\nIn upcoming posts, we will delve deeper into each component, exploring their configurations and roles in greater detail. Stay tuned as we continue to navigate the fascinating world of Kubernetes!\nCredit: This content is inspired by a lecture from KodeKloud.\n","wordCount":"515","inLanguage":"en","image":"https://bookofdaniel.in/images/k8s-ship-analogy-kodekloud.webp","datePublished":"2024-09-12T13:52:32+05:30","dateModified":"2024-09-12T13:52:32+05:30","author":[{"@type":"Person","name":"Dan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://bookofdaniel.in/posts/kubernetes-architecture-explained-the-ship-analogy-of-kodekloud/"},"publisher":{"@type":"Organization","name":"Book of Daniel","logo":{"@type":"ImageObject","url":"https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bookofdaniel.in/ accesskey=h title="Book of Daniel (Alt + H)">Book of Daniel</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bookofdaniel.in/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://bookofdaniel.in/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bookofdaniel.in/>Home</a>&nbsp;»&nbsp;<a href=https://bookofdaniel.in/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kubernetes Architecture Explained the Ship Analogy of KodeKloud</h1><div class=post-meta><span title='2024-09-12 13:52:32 +0530 +0530'>September 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;515 words&nbsp;·&nbsp;Dan</div></header><figure class=entry-cover><img loading=eager src=https://bookofdaniel.in/images/k8s-ship-analogy-kodekloud.webp alt="credit: KodeKloud"><p>credit: KodeKloud</p></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-kubernetes-cluster-ships-at-sea aria-label="The Kubernetes Cluster: Ships at Sea">The Kubernetes Cluster: Ships at Sea</a></li><li><a href=#master-nodes-the-control-ships aria-label="Master Nodes: The Control Ships">Master Nodes: The Control Ships</a></li><li><a href=#worker-nodes-the-cargo-ships aria-label="Worker Nodes: The Cargo Ships">Worker Nodes: The Cargo Ships</a></li><li><a href=#container-runtime aria-label="Container Runtime">Container Runtime</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Welcome to our exploration of Kubernetes architecture! Kubernetes, often abbreviated as K8s, is a powerful tool designed to manage containerized applications in a scalable and automated fashion. This blog post aims to provide a high-level understanding of Kubernetes architecture using an analogy of ships, which simplifies the complex interplay between its components. Special thanks to KodeKloud for their insightful lecture, which inspired this overview.</p><h3 id=the-kubernetes-cluster-ships-at-sea>The Kubernetes Cluster: Ships at Sea<a hidden class=anchor aria-hidden=true href=#the-kubernetes-cluster-ships-at-sea>#</a></h3><p>At its core, a Kubernetes cluster comprises two types of nodes: worker nodes and master nodes. To understand their roles, let&rsquo;s imagine a fleet of ships:</p><ul><li><strong>Worker Nodes (Cargo Ships)</strong>: These ships carry the actual load—in Kubernetes, this translates to running your containerized applications.</li><li><strong>Master Nodes (Control Ships)</strong>: These ships oversee and manage the cargo ships, ensuring everything runs smoothly.</li></ul><h3 id=master-nodes-the-control-ships>Master Nodes: The Control Ships<a hidden class=anchor aria-hidden=true href=#master-nodes-the-control-ships>#</a></h3><p>Master nodes are the brain of the Kubernetes cluster, managing the state and operations of the entire system. They contain several key components, collectively known as the control plane:</p><ol><li><p><strong>etcd</strong>: A highly available key-value store that keeps all cluster data. Think of it as the central database that logs the details of every ship and container.</p></li><li><p><strong>Kube Scheduler</strong>: Similar to cranes that load containers onto ships, the Kube Scheduler assigns containers to nodes based on resource requirements, node capacity, and various constraints like node affinity and tolerations.</p></li><li><p><strong>Controllers</strong>: These are specialized offices on the control ships handling specific tasks:</p><ul><li><strong>Node Controller</strong>: Manages the state of nodes, ensuring they are operational and adding new ones to the cluster as needed.</li><li><strong>Replication Controller</strong>: Ensures the desired number of container replicas are running at all times.</li></ul></li><li><p><strong>Kube API Server</strong>: The central management component that orchestrates all operations within the cluster. It exposes the Kubernetes API, allowing users and controllers to interact with the cluster, monitor its state, and make necessary changes.</p></li></ol><h3 id=worker-nodes-the-cargo-ships>Worker Nodes: The Cargo Ships<a hidden class=anchor aria-hidden=true href=#worker-nodes-the-cargo-ships>#</a></h3><p>Worker nodes are where your applications run, managed by two key components:</p><ol><li><p><strong>Kubelet</strong>: The captain of the ship, responsible for communicating with the Kube API Server, receiving instructions, and managing containers on the node. The Kubelet also sends status reports back to the master nodes.</p></li><li><p><strong>Kube-proxy</strong>: Ensures smooth communication between containers across different nodes by maintaining network rules on each node. This is essential for services to interact seamlessly, like a web server on one node communicating with a database server on another.</p></li></ol><h3 id=container-runtime>Container Runtime<a hidden class=anchor aria-hidden=true href=#container-runtime>#</a></h3><p>All nodes, whether master or worker, require a container runtime engine to run containers. While Docker is a popular choice, Kubernetes also supports other runtimes like containerd and CRI-O. This runtime environment is crucial for deploying containerized applications and components.</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>Kubernetes architecture, with its intricate components and interactions, ensures efficient and scalable management of containerized applications. By likening it to a fleet of ships with dedicated roles and responsibilities, we can better understand the complex but elegant orchestration that Kubernetes provides.</p><p>In upcoming posts, we will delve deeper into each component, exploring their configurations and roles in greater detail. Stay tuned as we continue to navigate the fascinating world of Kubernetes!</p><hr><p><em>Credit: This content is inspired by a lecture from KodeKloud.</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bookofdaniel.in/tags/k8s/>K8s</a></li></ul><nav class=paginav><a class=prev href=https://bookofdaniel.in/posts/lessons-learned-from-a-former-whatsapp-engineer/><span class=title>« Prev</span><br><span>Lessons Learned From a Former WhatsApp Engineer</span>
</a><a class=next href=https://bookofdaniel.in/posts/key-principles-of-any-cloud-environments/><span class=title>Next »</span><br><span>Key Principles of Any Cloud Environments</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=dannotes/bookofdaniel-comments data-repo-id=R_kgDOMwnsUw data-category=Comments data-category-id=DIC_kwDOMwnsU84CiaCW data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://bookofdaniel.in/>Book of Daniel</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>