<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Making Your Kafka Cluster Production-Ready with Strimzi: Best Practices | Book of Daniel</title>
<meta name=keywords content="kafka,strimzi"><meta name=description content="Apache Kafka is widely used for building distributed, real-time data pipelines. However, running Kafka in a production environment requires a solid setup to ensure performance, reliability, and scalability. Strimzi simplifies deploying and managing Kafka clusters on Kubernetes or OpenShift, but to be truly production-ready, several factors need to be considered. In this article, we will cover essential best practices and optimizations to make your Kafka cluster ready for production, based on insights from the Strimzi Production Ready series and additional knowledge."><meta name=author content="Dan"><link rel=canonical href=https://bookofdaniel.in/posts/making-your-kafka-cluster-production-ready-with-strimzi/><meta name=google-site-verification content="G-VXV565Z72E"><link crossorigin=anonymous href=/assets/css/stylesheet.c2c7686f60e02d1020ae178866d16d8c27015be46b6a30dd6592d750860617d9.css integrity="sha256-wsdob2DgLRAgrheIZtFtjCcBW+RrajDdZZLXUIYGF9k=" rel="preload stylesheet" as=style><link rel=icon href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bookofdaniel.in/posts/making-your-kafka-cluster-production-ready-with-strimzi/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-VXV565Z72E"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VXV565Z72E")}</script><meta property="og:title" content="Making Your Kafka Cluster Production-Ready with Strimzi: Best Practices"><meta property="og:description" content="Apache Kafka is widely used for building distributed, real-time data pipelines. However, running Kafka in a production environment requires a solid setup to ensure performance, reliability, and scalability. Strimzi simplifies deploying and managing Kafka clusters on Kubernetes or OpenShift, but to be truly production-ready, several factors need to be considered. In this article, we will cover essential best practices and optimizations to make your Kafka cluster ready for production, based on insights from the Strimzi Production Ready series and additional knowledge."><meta property="og:type" content="article"><meta property="og:url" content="https://bookofdaniel.in/posts/making-your-kafka-cluster-production-ready-with-strimzi/"><meta property="og:image" content="https://bookofdaniel.in/images/kafka-production-ready.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-22T17:45:52+05:30"><meta property="article:modified_time" content="2024-10-22T17:45:52+05:30"><meta property="og:site_name" content="Book of Daniel"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bookofdaniel.in/images/kafka-production-ready.png"><meta name=twitter:title content="Making Your Kafka Cluster Production-Ready with Strimzi: Best Practices"><meta name=twitter:description content="Apache Kafka is widely used for building distributed, real-time data pipelines. However, running Kafka in a production environment requires a solid setup to ensure performance, reliability, and scalability. Strimzi simplifies deploying and managing Kafka clusters on Kubernetes or OpenShift, but to be truly production-ready, several factors need to be considered. In this article, we will cover essential best practices and optimizations to make your Kafka cluster ready for production, based on insights from the Strimzi Production Ready series and additional knowledge."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bookofdaniel.in/posts/"},{"@type":"ListItem","position":2,"name":"Making Your Kafka Cluster Production-Ready with Strimzi: Best Practices","item":"https://bookofdaniel.in/posts/making-your-kafka-cluster-production-ready-with-strimzi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Making Your Kafka Cluster Production-Ready with Strimzi: Best Practices","name":"Making Your Kafka Cluster Production-Ready with Strimzi: Best Practices","description":"Apache Kafka is widely used for building distributed, real-time data pipelines. However, running Kafka in a production environment requires a solid setup to ensure performance, reliability, and scalability. Strimzi simplifies deploying and managing Kafka clusters on Kubernetes or OpenShift, but to be truly production-ready, several factors need to be considered. In this article, we will cover essential best practices and optimizations to make your Kafka cluster ready for production, based on insights from the Strimzi Production Ready series and additional knowledge.\n","keywords":["kafka","strimzi"],"articleBody":"Apache Kafka is widely used for building distributed, real-time data pipelines. However, running Kafka in a production environment requires a solid setup to ensure performance, reliability, and scalability. Strimzi simplifies deploying and managing Kafka clusters on Kubernetes or OpenShift, but to be truly production-ready, several factors need to be considered. In this article, we will cover essential best practices and optimizations to make your Kafka cluster ready for production, based on insights from the Strimzi Production Ready series and additional knowledge.\n1. Cluster Balancing As Kafka clusters grow, partitions might become unevenly distributed across brokers. This can lead to resource bottlenecks, where some brokers handle too many partitions while others remain underutilized.\nHow to Balance Partitions Strimzi uses the Kafka Rebalance custom resource to rebalance partitions across brokers. This feature ensures better resource distribution and prevents some brokers from being overloaded.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 apiVersion: kafka.strimzi.io/v1alpha1 kind: KafkaRebalance metadata: name: my-rebalance labels: strimzi.io/cluster: my-cluster spec: goals: - NetworkInboundCapacityGoal - DiskCapacityGoal - RackAwareGoal - NetworkOutboundCapacityGoal - CpuCapacityGoal - ReplicaCapacityGoal By specifying goals such as NetworkInboundCapacityGoal and DiskCapacityGoal, the rebalancer ensures that brokers’ resources are better utilized, reducing bottlenecks.\nAdditional Tip: Rebalance Frequency Rebalance Kafka clusters periodically, especially after adding or removing brokers. However, avoid over-rebalancing, as it can lead to performance degradation during the rebalance process.\n2. Optimizing Local Storage Storage configuration plays a major role in Kafka’s performance. While using local storage may improve I/O performance, there are trade-offs to consider.\nLocal Storage Pros and Cons Advantages: Local storage (e.g., SSDs attached directly to the broker node) offers low-latency read/write operations, reducing the overhead associated with network storage. Disadvantages: When a node goes offline for maintenance or crashes, its local storage becomes unavailable, requiring manual cleanup of Persistent Volumes (PV) and Persistent Volume Claims (PVC) in Kubernetes. Moreover, resyncing data to the newly provisioned node can take time. Recommendation: If you choose local storage, have a robust monitoring and disaster recovery plan. For mission-critical workloads, consider distributed storage that isn’t tied to a single node.\n3. Handling Multiple Disks for Kafka While multiple disks offer more storage, they don’t necessarily improve bandwidth or throughput. Kafka partitions cannot span multiple disks, so you must carefully plan disk usage.\nBest Practice: JBOD (Just a Bunch Of Disks) Using JBOD can help combine multiple disks, but the limitation remains that a single partition will still reside on a single disk. Rebalancing partitions is necessary to ensure even distribution of disk usage.\nAdditional Insights: Using a single large disk per broker is often better from a management and performance perspective, as it avoids idle disks and uneven partition distribution. Strimzi makes it easy to configure JBOD in the Kafka CRD, and it’s often the best choice for scaling storage without adding complexity. 4. Improving Reliability Reliability is key in any production environment. Kafka is designed to replicate data across brokers, but the default configuration might not be suitable for high-reliability requirements.\nProducer Acknowledgments and Replication Factor By default, Kafka producers use acks=1, meaning they only wait for the leader to confirm the receipt of a message. In production, it’s advisable to set acks=all or -1 to ensure that the producer waits for both the leader and all in-sync replicas to acknowledge.\nYou should also configure the replication factor for your topics. For most production use cases, a replication factor of 3 ensures high availability and fault tolerance.\n1 2 3 4 config: offsets.topic.replication.factor: 3 transaction.state.log.replication.factor: 3 min.insync.replicas: 2 Rolling Updates and Fault Tolerance Strimzi’s rolling update feature ensures that brokers are updated one by one. It waits for each broker to sync all messages before proceeding to the next broker, ensuring minimal disruption during updates. Configuring a proper min.insync.replicas guarantees Kafka can continue processing messages even if one broker is down for maintenance.\n5. CPU and Memory Resource Management In Kubernetes, managing CPU and memory resources is critical to ensuring Kafka’s stability and performance. Strimzi allows you to specify requests and limits for CPU and memory.\nCPU Resources: Kafka brokers rely heavily on CPU for handling client connections, managing partitions, and replication. Set requests to match the expected baseline usage, and configure limits based on peak performance.\n1 2 3 4 5 6 7 resources: requests: memory: 16Gi cpu: 4 limits: memory: 16Gi cpu: 8 Memory Management: Kafka relies on JVM memory, including heap memory and off-heap (page cache). The recommended approach is to configure the heap size for Kafka brokers (using KAFKA_HEAP_OPTS), while ensuring you leave enough memory for off-heap operations.\n1 KAFKA_HEAP_OPTS=\"-Xms4G -Xmx4G\" In Strimzi, these JVM settings can be specified directly in the Kafka CRD.\n6. Dedicated Nodes and Node Affinity To ensure that Kafka doesn’t compete for resources with other applications, it’s a good idea to dedicate worker nodes to Kafka by using node taints and affinities. Taints prevent non-Kafka workloads from being scheduled on these nodes.\n1 2 kubectl taint node worker-node-04 dedicated=kafka:NoSchedule kubectl label node worker-node-04 dedicated=kafka Node affinity ensures that Kafka pods are placed on specific nodes dedicated to Kafka, allowing for better resource isolation and performance.\n7. Storage Options for Kafka in Kubernetes Kafka’s performance depends on the type of storage used. Strimzi supports three types of storage: Ephemeral, Persistent, and JBOD.\nPersistent Storage: For production, always prefer Persistent Volumes (PVs) backed by SSDs. Strimzi makes it easy to configure PVs and Persistent Volume Claims (PVCs) for durable, high-performance storage.\nJBOD Storage: For scaling storage without the complexity of RAID configurations, JBOD is a recommended approach. JBOD combines multiple disks into a single storage resource, which works well for Kafka brokers.\nAvoid NFS: Network File Systems (NFS) are not ideal for Kafka due to performance bottlenecks. Stick with block storage such as xfs or ext4 formatted disks.\n8. Rack-Awareness and Multi-Zone Deployment Kafka is designed to be resilient across failure domains such as availability zones. Strimzi supports rack-awareness, which allows you to spread Kafka brokers and replicas across different zones for high availability.\nRack-Awareness Configuration: Enable rack-awareness in Strimzi to ensure that replicas are not placed on the same failure domain. Strimzi will automatically handle affinities and distribute brokers evenly across zones.\n9. Disaster Recovery and Backups Kafka itself does not have built-in disaster recovery mechanisms, so backups are critical for production deployments.\nBest Practices: Use Strimzi’s backup capabilities to store Kafka configuration and metadata. Automate regular backups of topic data and Kafka configurations (topic definitions, ACLs, etc.). Ensure that your backup strategy covers Zookeeper data (if you’re not using KRaft mode). Conclusion Setting up Kafka for production using Strimzi requires attention to detail in several areas—storage configuration, resource management, partition rebalancing, and fault tolerance. By following these best practices, you can ensure that your Kafka cluster is scalable, reliable, and optimized for high throughput in production environments.\nStrimzi simplifies much of the complexity, but it’s important to understand the underlying components to make the most of your Kafka deployment. Whether you’re scaling horizontally or managing high availability across multiple zones, these guidelines will help you maintain a robust and resilient Kafka cluster.\nFor further learning, you can explore the Strimzi Production Ready YouTube Playlist here, which provided many of the key insights covered in this article.\nCredits to the Strimzi Community for their valuable insights in the playlist.\n","wordCount":"1214","inLanguage":"en","image":"https://bookofdaniel.in/images/kafka-production-ready.png","datePublished":"2024-10-22T17:45:52+05:30","dateModified":"2024-10-22T17:45:52+05:30","author":[{"@type":"Person","name":"Dan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://bookofdaniel.in/posts/making-your-kafka-cluster-production-ready-with-strimzi/"},"publisher":{"@type":"Organization","name":"Book of Daniel","logo":{"@type":"ImageObject","url":"https://bookofdaniel.in/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bookofdaniel.in/ accesskey=h title="Book of Daniel (Alt + H)">Book of Daniel</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bookofdaniel.in/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://bookofdaniel.in/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bookofdaniel.in/>Home</a>&nbsp;»&nbsp;<a href=https://bookofdaniel.in/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Making Your Kafka Cluster Production-Ready with Strimzi: Best Practices</h1><div class=post-meta><span title='2024-10-22 17:45:52 +0530 +0530'>October 22, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1214 words&nbsp;·&nbsp;Dan</div></header><figure class=entry-cover><img loading=eager src=https://bookofdaniel.in/images/kafka-production-ready.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-cluster-balancing aria-label="1. Cluster Balancing">1. <strong>Cluster Balancing</strong></a><ul><li><a href=#how-to-balance-partitions aria-label="How to Balance Partitions"><strong>How to Balance Partitions</strong></a></li><li><a href=#additional-tip-rebalance-frequency aria-label="Additional Tip: Rebalance Frequency"><strong>Additional Tip: Rebalance Frequency</strong></a></li></ul></li><li><a href=#2-optimizing-local-storage aria-label="2. Optimizing Local Storage">2. <strong>Optimizing Local Storage</strong></a><ul><li><a href=#local-storage-pros-and-cons aria-label="Local Storage Pros and Cons"><strong>Local Storage Pros and Cons</strong></a></li></ul></li><li><a href=#3-handling-multiple-disks-for-kafka aria-label="3. Handling Multiple Disks for Kafka">3. <strong>Handling Multiple Disks for Kafka</strong></a><ul><li><a href=#best-practice-jbod-just-a-bunch-of-disks aria-label="Best Practice: JBOD (Just a Bunch Of Disks)"><strong>Best Practice: JBOD (Just a Bunch Of Disks)</strong></a></li><li><a href=#additional-insights aria-label="Additional Insights:"><strong>Additional Insights</strong>:</a></li></ul></li><li><a href=#4-improving-reliability aria-label="4. Improving Reliability">4. <strong>Improving Reliability</strong></a><ul><li><a href=#producer-acknowledgments-and-replication-factor aria-label="Producer Acknowledgments and Replication Factor"><strong>Producer Acknowledgments and Replication Factor</strong></a></li><li><a href=#rolling-updates-and-fault-tolerance aria-label="Rolling Updates and Fault Tolerance"><strong>Rolling Updates and Fault Tolerance</strong></a></li></ul></li><li><a href=#5-cpu-and-memory-resource-management aria-label="5. CPU and Memory Resource Management">5. <strong>CPU and Memory Resource Management</strong></a><ul><li><a href=#cpu-resources aria-label="CPU Resources:"><strong>CPU Resources</strong>:</a></li><li><a href=#memory-management aria-label="Memory Management:"><strong>Memory Management</strong>:</a></li></ul></li><li><a href=#6-dedicated-nodes-and-node-affinity aria-label="6. Dedicated Nodes and Node Affinity">6. <strong>Dedicated Nodes and Node Affinity</strong></a></li><li><a href=#7-storage-options-for-kafka-in-kubernetes aria-label="7. Storage Options for Kafka in Kubernetes">7. <strong>Storage Options for Kafka in Kubernetes</strong></a><ul><li><a href=#persistent-storage aria-label="Persistent Storage:"><strong>Persistent Storage</strong>:</a></li><li><a href=#jbod-storage aria-label="JBOD Storage:"><strong>JBOD Storage</strong>:</a></li><li><a href=#avoid-nfs aria-label="Avoid NFS:"><strong>Avoid NFS</strong>:</a></li></ul></li><li><a href=#8-rack-awareness-and-multi-zone-deployment aria-label="8. Rack-Awareness and Multi-Zone Deployment">8. <strong>Rack-Awareness and Multi-Zone Deployment</strong></a><ul><li><a href=#rack-awareness-configuration aria-label="Rack-Awareness Configuration:"><strong>Rack-Awareness Configuration</strong>:</a></li></ul></li><li><a href=#9-disaster-recovery-and-backups aria-label="9. Disaster Recovery and Backups">9. <strong>Disaster Recovery and Backups</strong></a><ul><li><a href=#best-practices aria-label="Best Practices:"><strong>Best Practices</strong>:</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Apache Kafka is widely used for building distributed, real-time data pipelines. However, running Kafka in a production environment requires a solid setup to ensure performance, reliability, and scalability. Strimzi simplifies deploying and managing Kafka clusters on Kubernetes or OpenShift, but to be truly production-ready, several factors need to be considered. In this article, we will cover essential best practices and optimizations to make your Kafka cluster ready for production, based on insights from the Strimzi Production Ready series and additional knowledge.</p><h2 id=1-cluster-balancing>1. <strong>Cluster Balancing</strong><a hidden class=anchor aria-hidden=true href=#1-cluster-balancing>#</a></h2><p>As Kafka clusters grow, partitions might become unevenly distributed across brokers. This can lead to resource bottlenecks, where some brokers handle too many partitions while others remain underutilized.</p><h3 id=how-to-balance-partitions><strong>How to Balance Partitions</strong><a hidden class=anchor aria-hidden=true href=#how-to-balance-partitions>#</a></h3><p>Strimzi uses the <a href=https://strimzi.io/docs/operators/latest/overview#metrics-overview-cruisecontrol_str><strong>Kafka Rebalance</strong></a> custom resource to rebalance partitions across brokers. This feature ensures better resource distribution and prevents some brokers from being overloaded.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>kafka.strimzi.io/v1alpha1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>KafkaRebalance</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-rebalance</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>strimzi.io/cluster</span><span class=p>:</span><span class=w> </span><span class=l>my-cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>goals</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>NetworkInboundCapacityGoal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>DiskCapacityGoal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>RackAwareGoal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>NetworkOutboundCapacityGoal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>CpuCapacityGoal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>ReplicaCapacityGoal</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>By specifying goals such as <code>NetworkInboundCapacityGoal</code> and <code>DiskCapacityGoal</code>, the rebalancer ensures that brokers&rsquo; resources are better utilized, reducing bottlenecks.</p><h3 id=additional-tip-rebalance-frequency><strong>Additional Tip: Rebalance Frequency</strong><a hidden class=anchor aria-hidden=true href=#additional-tip-rebalance-frequency>#</a></h3><p>Rebalance Kafka clusters periodically, especially after adding or removing brokers. However, avoid over-rebalancing, as it can lead to performance degradation during the rebalance process.</p><h2 id=2-optimizing-local-storage>2. <strong>Optimizing Local Storage</strong><a hidden class=anchor aria-hidden=true href=#2-optimizing-local-storage>#</a></h2><p>Storage configuration plays a major role in Kafka&rsquo;s performance. While using local storage may improve I/O performance, there are trade-offs to consider.</p><h3 id=local-storage-pros-and-cons><strong>Local Storage Pros and Cons</strong><a hidden class=anchor aria-hidden=true href=#local-storage-pros-and-cons>#</a></h3><ul><li><strong>Advantages</strong>: Local storage (e.g., SSDs attached directly to the broker node) offers low-latency read/write operations, reducing the overhead associated with network storage.</li><li><strong>Disadvantages</strong>: When a node goes offline for maintenance or crashes, its local storage becomes unavailable, requiring manual cleanup of Persistent Volumes (PV) and Persistent Volume Claims (PVC) in Kubernetes. Moreover, resyncing data to the newly provisioned node can take time.</li></ul><blockquote><p><strong>Recommendation:</strong> If you choose local storage, have a robust monitoring and disaster recovery plan. For mission-critical workloads, consider distributed storage that isn’t tied to a single node.</p></blockquote><h2 id=3-handling-multiple-disks-for-kafka>3. <strong>Handling Multiple Disks for Kafka</strong><a hidden class=anchor aria-hidden=true href=#3-handling-multiple-disks-for-kafka>#</a></h2><p>While multiple disks offer more <a href=https://strimzi.io/docs/operators/latest/overview#storage>storage</a>, they don&rsquo;t necessarily improve bandwidth or throughput. Kafka partitions cannot span multiple disks, so you must carefully plan disk usage.</p><h3 id=best-practice-jbod-just-a-bunch-of-disks><strong>Best Practice: JBOD (Just a Bunch Of Disks)</strong><a hidden class=anchor aria-hidden=true href=#best-practice-jbod-just-a-bunch-of-disks>#</a></h3><p>Using JBOD can help combine multiple disks, but the limitation remains that a single partition will still reside on a single disk. Rebalancing partitions is necessary to ensure even distribution of disk usage.</p><h3 id=additional-insights><strong>Additional Insights</strong>:<a hidden class=anchor aria-hidden=true href=#additional-insights>#</a></h3><ul><li>Using a <strong>single large disk</strong> per broker is often better from a management and performance perspective, as it avoids idle disks and uneven partition distribution.</li><li>Strimzi makes it easy to configure JBOD in the Kafka CRD, and it&rsquo;s often the best choice for scaling storage without adding complexity.</li></ul><h2 id=4-improving-reliability>4. <strong>Improving Reliability</strong><a hidden class=anchor aria-hidden=true href=#4-improving-reliability>#</a></h2><p>Reliability is key in any production environment. Kafka is designed to<a href=https://strimzi.io/docs/operators/latest/overview#configuration-points-connect_str> replicate data across brokers</a>, but the default configuration might not be suitable for high-reliability requirements.</p><h3 id=producer-acknowledgments-and-replication-factor><strong>Producer Acknowledgments and Replication Factor</strong><a hidden class=anchor aria-hidden=true href=#producer-acknowledgments-and-replication-factor>#</a></h3><p>By default, Kafka producers use <code>acks=1</code>, meaning they only wait for the leader to confirm the receipt of a message. In production, it&rsquo;s advisable to set <code>acks=all</code> or <code>-1</code> to ensure that the producer waits for both the leader and all in-sync replicas to acknowledge.</p><p>You should also configure the <strong>replication factor</strong> for your topics. For most production use cases, a replication factor of 3 ensures high availability and fault tolerance.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>config</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>offsets.topic.replication.factor</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>transaction.state.log.replication.factor</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>min.insync.replicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=rolling-updates-and-fault-tolerance><strong>Rolling Updates and Fault Tolerance</strong><a hidden class=anchor aria-hidden=true href=#rolling-updates-and-fault-tolerance>#</a></h3><p>Strimzi’s rolling update feature ensures that brokers are updated one by one. It waits for each broker to sync all messages before proceeding to the next broker, ensuring minimal disruption during updates. Configuring a proper <code>min.insync.replicas</code> guarantees Kafka can continue processing messages even if one broker is down for maintenance.</p><h2 id=5-cpu-and-memory-resource-management>5. <strong>CPU and Memory Resource Management</strong><a hidden class=anchor aria-hidden=true href=#5-cpu-and-memory-resource-management>#</a></h2><p>In Kubernetes, <a href=https://strimzi.io/docs/operators/latest/overview#configuration-points-common_str>managing CPU and memory resources</a> is critical to ensuring Kafka’s stability and performance. Strimzi allows you to specify <strong>requests</strong> and <strong>limits</strong> for CPU and memory.</p><h3 id=cpu-resources><strong>CPU Resources</strong>:<a hidden class=anchor aria-hidden=true href=#cpu-resources>#</a></h3><p>Kafka brokers rely heavily on CPU for handling client connections, managing partitions, and replication. Set <strong>requests</strong> to match the expected baseline usage, and configure <strong>limits</strong> based on peak performance.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=l>16Gi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=m>4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=l>16Gi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=m>8</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=memory-management><strong>Memory Management</strong>:<a hidden class=anchor aria-hidden=true href=#memory-management>#</a></h3><p>Kafka relies on JVM memory, including heap memory and off-heap (page cache). The recommended approach is to configure the heap size for Kafka brokers (using <code>KAFKA_HEAP_OPTS</code>), while ensuring you leave enough memory for off-heap operations.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>KAFKA_HEAP_OPTS=&#34;-Xms4G -Xmx4G&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>In Strimzi, these JVM settings can be specified directly in the Kafka CRD.</p><h2 id=6-dedicated-nodes-and-node-affinity>6. <strong>Dedicated Nodes and Node Affinity</strong><a hidden class=anchor aria-hidden=true href=#6-dedicated-nodes-and-node-affinity>#</a></h2><p>To ensure that Kafka doesn&rsquo;t compete for resources with other applications, it’s a good idea to dedicate worker nodes to Kafka by using <strong>node taints</strong> and <strong>affinities</strong>. Taints prevent non-Kafka workloads from being scheduled on these nodes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl taint node worker-node-04 <span class=nv>dedicated</span><span class=o>=</span>kafka:NoSchedule
</span></span><span class=line><span class=cl>kubectl label node worker-node-04 <span class=nv>dedicated</span><span class=o>=</span>kafka
</span></span></code></pre></td></tr></table></div></div><p>Node affinity ensures that Kafka pods are placed on specific nodes dedicated to Kafka, allowing for better resource isolation and performance.</p><h2 id=7-storage-options-for-kafka-in-kubernetes>7. <strong>Storage Options for Kafka in Kubernetes</strong><a hidden class=anchor aria-hidden=true href=#7-storage-options-for-kafka-in-kubernetes>#</a></h2><p>Kafka’s performance depends on the type of <a href=https://strimzi.io/docs/operators/latest/overview#storage>storage used</a>. Strimzi supports three types of storage: <strong>Ephemeral</strong>, <strong>Persistent</strong>, and <strong>JBOD</strong>.</p><h3 id=persistent-storage><strong>Persistent Storage</strong>:<a hidden class=anchor aria-hidden=true href=#persistent-storage>#</a></h3><p>For production, always prefer <strong>Persistent Volumes</strong> (PVs) backed by SSDs. Strimzi makes it easy to configure PVs and Persistent Volume Claims (PVCs) for durable, high-performance storage.</p><h3 id=jbod-storage><strong>JBOD Storage</strong>:<a hidden class=anchor aria-hidden=true href=#jbod-storage>#</a></h3><p>For scaling storage without the complexity of RAID configurations, JBOD is a recommended approach. JBOD combines multiple disks into a single storage resource, which works well for Kafka brokers.</p><h3 id=avoid-nfs><strong>Avoid NFS</strong>:<a hidden class=anchor aria-hidden=true href=#avoid-nfs>#</a></h3><p>Network File Systems (NFS) are not ideal for Kafka due to performance bottlenecks. Stick with <strong>block storage</strong> such as <strong>xfs</strong> or <strong>ext4</strong> formatted disks.</p><h2 id=8-rack-awareness-and-multi-zone-deployment>8. <strong>Rack-Awareness and Multi-Zone Deployment</strong><a hidden class=anchor aria-hidden=true href=#8-rack-awareness-and-multi-zone-deployment>#</a></h2><p>Kafka is designed to be resilient across failure domains such as availability zones. Strimzi supports <a href=https://strimzi.io/docs/operators/latest/overview#rack_awareness><strong>rack-awareness</strong></a>, which allows you to spread Kafka brokers and replicas across different zones for high availability.</p><h3 id=rack-awareness-configuration><strong>Rack-Awareness Configuration</strong>:<a hidden class=anchor aria-hidden=true href=#rack-awareness-configuration>#</a></h3><p>Enable rack-awareness in Strimzi to ensure that replicas are not placed on the same failure domain. Strimzi will automatically handle affinities and distribute brokers evenly across zones.</p><h2 id=9-disaster-recovery-and-backups>9. <strong>Disaster Recovery and Backups</strong><a hidden class=anchor aria-hidden=true href=#9-disaster-recovery-and-backups>#</a></h2><p>Kafka itself does not have built-in disaster recovery mechanisms, so backups are critical for production deployments.</p><h3 id=best-practices><strong>Best Practices</strong>:<a hidden class=anchor aria-hidden=true href=#best-practices>#</a></h3><ul><li>Use Strimzi’s backup capabilities to store Kafka configuration and metadata.</li><li>Automate regular backups of <strong>topic data</strong> and <strong>Kafka configurations</strong> (topic definitions, ACLs, etc.).</li><li>Ensure that your backup strategy covers <strong>Zookeeper data</strong> (if you&rsquo;re not using KRaft mode).</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Setting up Kafka for production using Strimzi requires attention to detail in several areas—storage configuration, resource management, partition rebalancing, and fault tolerance. By following these best practices, you can ensure that your Kafka cluster is scalable, reliable, and optimized for high throughput in production environments.</p><p>Strimzi simplifies much of the complexity, but it’s important to understand the underlying components to make the most of your Kafka deployment. Whether you’re scaling horizontally or managing high availability across multiple zones, these guidelines will help you maintain a robust and resilient Kafka cluster.</p><p>For further learning, you can explore the Strimzi Production Ready YouTube Playlist <a href="https://www.youtube.com/watch?v=WPt8ScjK8wc&amp;list=PLpI4X8PMthYeCSpy9a-mGtvDbMgqGNYNy">here</a>, which provided many of the key insights covered in this article.</p><p>Credits to the <a href=https://strimzi.io/>Strimzi Community</a> for their valuable insights in the playlist.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bookofdaniel.in/tags/kafka/>Kafka</a></li><li><a href=https://bookofdaniel.in/tags/strimzi/>Strimzi</a></li></ul><nav class=paginav><a class=prev href=https://bookofdaniel.in/posts/how-i-passed-the-cks-exam-after-the-october-revamp/><span class=title>« Prev</span><br><span>How I Passed the CKS Exam After the October Revamp</span>
</a><a class=next href=https://bookofdaniel.in/posts/passing-ckad-after-your-cka/><span class=title>Next »</span><br><span>Passing CKAD After Your CKA</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=dannotes/bookofdaniel-comments data-repo-id=R_kgDOMwnsUw data-category=Comments data-category-id=DIC_kwDOMwnsU84CiaCW data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://bookofdaniel.in/>Book of Daniel</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>